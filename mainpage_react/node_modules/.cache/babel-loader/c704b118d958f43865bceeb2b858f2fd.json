{"ast":null,"code":"var httpNative = require('http'),\n    httpsNative = require('https'),\n    web_o = require('./web-outgoing'),\n    common = require('../common'),\n    followRedirects = require('follow-redirects');\n\nweb_o = Object.keys(web_o).map(function (pass) {\n  return web_o[pass];\n});\nvar nativeAgents = {\n  http: httpNative,\n  https: httpsNative\n};\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\nmodule.exports = {\n  /**\n   * Sets `content-length` to '0' if request is of DELETE type.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  deleteLength: function deleteLength(req, res, options) {\n    if ((req.method === 'DELETE' || req.method === 'OPTIONS') && !req.headers['content-length']) {\n      req.headers['content-length'] = '0';\n      delete req.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * Sets timeout in request socket if it was specified in options.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  timeout: function timeout(req, res, options) {\n    if (options.timeout) {\n      req.socket.setTimeout(options.timeout);\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  XHeaders: function XHeaders(req, res, options) {\n    if (!options.xfwd) return;\n    var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n    var values = {\n      for: req.connection.remoteAddress || req.socket.remoteAddress,\n      port: common.getPort(req),\n      proto: encrypted ? 'https' : 'http'\n    };\n    ['for', 'port', 'proto'].forEach(function (header) {\n      req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n    });\n    req.headers['x-forwarded-host'] = req.headers['x-forwarded-host'] || req.headers['host'] || '';\n  },\n\n  /**\n   * Does the actual proxying. If `forward` is enabled fires up\n   * a ForwardStream, same happens for ProxyStream. The request\n   * just dies otherwise.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  stream: function stream(req, res, options, _, server, clb) {\n    // And we begin!\n    server.emit('start', req, res, options.target || options.forward);\n    var agents = options.followRedirects ? followRedirects : nativeAgents;\n    var http = agents.http;\n    var https = agents.https;\n\n    if (options.forward) {\n      // If forward enable, so just pipe the request\n      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req, 'forward')); // error handler (e.g. ECONNRESET, ECONNREFUSED)\n      // Handle errors on incoming request as well as it makes sense to\n\n      var forwardError = createErrorHandler(forwardReq, options.forward);\n      req.on('error', forwardError);\n      forwardReq.on('error', forwardError);\n      (options.buffer || req).pipe(forwardReq);\n\n      if (!options.target) {\n        return res.end();\n      }\n    } // Request initalization\n\n\n    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req)); // Enable developers to modify the proxyReq before headers are sent\n\n    proxyReq.on('socket', function (socket) {\n      if (server && !proxyReq.getHeader('expect')) {\n        server.emit('proxyReq', proxyReq, req, res, options);\n      }\n    }); // allow outgoing socket to timeout so that we could\n    // show an error page at the initial request\n\n    if (options.proxyTimeout) {\n      proxyReq.setTimeout(options.proxyTimeout, function () {\n        proxyReq.abort();\n      });\n    } // Ensure we abort proxy if request is aborted\n\n\n    req.on('aborted', function () {\n      proxyReq.abort();\n    }); // handle errors in proxy and incoming request, just like for forward proxy\n\n    var proxyError = createErrorHandler(proxyReq, options.target);\n    req.on('error', proxyError);\n    proxyReq.on('error', proxyError);\n\n    function createErrorHandler(proxyReq, url) {\n      return function proxyError(err) {\n        if (req.socket.destroyed && err.code === 'ECONNRESET') {\n          server.emit('econnreset', err, req, res, url);\n          return proxyReq.abort();\n        }\n\n        if (clb) {\n          clb(err, req, res, url);\n        } else {\n          server.emit('error', err, req, res, url);\n        }\n      };\n    }\n\n    (options.buffer || req).pipe(proxyReq);\n    proxyReq.on('response', function (proxyRes) {\n      if (server) {\n        server.emit('proxyRes', proxyRes, req, res);\n      }\n\n      if (!res.headersSent && !options.selfHandleResponse) {\n        for (var i = 0; i < web_o.length; i++) {\n          if (web_o[i](req, res, proxyRes, options)) {\n            break;\n          }\n        }\n      }\n\n      if (!res.finished) {\n        // Allow us to listen when the proxy has completed\n        proxyRes.on('end', function () {\n          if (server) server.emit('end', req, res, proxyRes);\n        }); // We pipe to the response unless its expected to be handled by the user\n\n        if (!options.selfHandleResponse) proxyRes.pipe(res);\n      } else {\n        if (server) server.emit('end', req, res, proxyRes);\n      }\n    });\n  }\n};","map":{"version":3,"names":["httpNative","require","httpsNative","web_o","common","followRedirects","Object","keys","map","pass","nativeAgents","http","https","module","exports","deleteLength","req","res","options","method","headers","timeout","socket","setTimeout","XHeaders","xfwd","encrypted","isSpdy","hasEncryptedConnection","values","for","connection","remoteAddress","port","getPort","proto","forEach","header","stream","_","server","clb","emit","target","forward","agents","forwardReq","protocol","request","setupOutgoing","ssl","forwardError","createErrorHandler","on","buffer","pipe","end","proxyReq","getHeader","proxyTimeout","abort","proxyError","url","err","destroyed","code","proxyRes","headersSent","selfHandleResponse","i","length","finished"],"sources":["C:/Users/gram1/Desktop/Frontend-React/mainpage_react/node_modules/http-proxy/lib/http-proxy/passes/web-incoming.js"],"sourcesContent":["var httpNative   = require('http'),\n    httpsNative  = require('https'),\n    web_o  = require('./web-outgoing'),\n    common = require('../common'),\n    followRedirects = require('follow-redirects');\n\nweb_o = Object.keys(web_o).map(function(pass) {\n  return web_o[pass];\n});\n\nvar nativeAgents = { http: httpNative, https: httpsNative };\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n\nmodule.exports = {\n\n  /**\n   * Sets `content-length` to '0' if request is of DELETE type.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  deleteLength: function deleteLength(req, res, options) {\n    if((req.method === 'DELETE' || req.method === 'OPTIONS')\n       && !req.headers['content-length']) {\n      req.headers['content-length'] = '0';\n      delete req.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * Sets timeout in request socket if it was specified in options.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  timeout: function timeout(req, res, options) {\n    if(options.timeout) {\n      req.socket.setTimeout(options.timeout);\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  XHeaders: function XHeaders(req, res, options) {\n    if(!options.xfwd) return;\n\n    var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: encrypted ? 'https' : 'http'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n\n    req.headers['x-forwarded-host'] = req.headers['x-forwarded-host'] || req.headers['host'] || '';\n  },\n\n  /**\n   * Does the actual proxying. If `forward` is enabled fires up\n   * a ForwardStream, same happens for ProxyStream. The request\n   * just dies otherwise.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  stream: function stream(req, res, options, _, server, clb) {\n\n    // And we begin!\n    server.emit('start', req, res, options.target || options.forward);\n\n    var agents = options.followRedirects ? followRedirects : nativeAgents;\n    var http = agents.http;\n    var https = agents.https;\n\n    if(options.forward) {\n      // If forward enable, so just pipe the request\n      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(\n        common.setupOutgoing(options.ssl || {}, options, req, 'forward')\n      );\n\n      // error handler (e.g. ECONNRESET, ECONNREFUSED)\n      // Handle errors on incoming request as well as it makes sense to\n      var forwardError = createErrorHandler(forwardReq, options.forward);\n      req.on('error', forwardError);\n      forwardReq.on('error', forwardError);\n\n      (options.buffer || req).pipe(forwardReq);\n      if(!options.target) { return res.end(); }\n    }\n\n    // Request initalization\n    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n\n    // Enable developers to modify the proxyReq before headers are sent\n    proxyReq.on('socket', function(socket) {\n      if(server && !proxyReq.getHeader('expect')) {\n        server.emit('proxyReq', proxyReq, req, res, options);\n      }\n    });\n\n    // allow outgoing socket to timeout so that we could\n    // show an error page at the initial request\n    if(options.proxyTimeout) {\n      proxyReq.setTimeout(options.proxyTimeout, function() {\n         proxyReq.abort();\n      });\n    }\n\n    // Ensure we abort proxy if request is aborted\n    req.on('aborted', function () {\n      proxyReq.abort();\n    });\n\n    // handle errors in proxy and incoming request, just like for forward proxy\n    var proxyError = createErrorHandler(proxyReq, options.target);\n    req.on('error', proxyError);\n    proxyReq.on('error', proxyError);\n\n    function createErrorHandler(proxyReq, url) {\n      return function proxyError(err) {\n        if (req.socket.destroyed && err.code === 'ECONNRESET') {\n          server.emit('econnreset', err, req, res, url);\n          return proxyReq.abort();\n        }\n\n        if (clb) {\n          clb(err, req, res, url);\n        } else {\n          server.emit('error', err, req, res, url);\n        }\n      }\n    }\n\n    (options.buffer || req).pipe(proxyReq);\n\n    proxyReq.on('response', function(proxyRes) {\n      if(server) { server.emit('proxyRes', proxyRes, req, res); }\n\n      if(!res.headersSent && !options.selfHandleResponse) {\n        for(var i=0; i < web_o.length; i++) {\n          if(web_o[i](req, res, proxyRes, options)) { break; }\n        }\n      }\n\n      if (!res.finished) {\n        // Allow us to listen when the proxy has completed\n        proxyRes.on('end', function () {\n          if (server) server.emit('end', req, res, proxyRes);\n        });\n        // We pipe to the response unless its expected to be handled by the user\n        if (!options.selfHandleResponse) proxyRes.pipe(res);\n      } else {\n        if (server) server.emit('end', req, res, proxyRes);\n      }\n    });\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}