{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function getIndexFromScroll(offset, positions) {\n  let sliceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let sliceEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : positions.length;\n\n  if (positions.length <= 0) {\n    return -1;\n  }\n\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? getIndexFromScroll(offset, positions, sliceStart, pivot) : getIndexFromScroll(offset, positions, pivot + 1, sliceEnd);\n}\nexport const getRenderableIndexes = _ref2 => {\n  let {\n    firstIndex,\n    lastIndex,\n    buffer,\n    minFirstIndex,\n    maxLastIndex\n  } = _ref2;\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nexport const useGridVirtualScroller = props => {\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerWidth, setContainerWidth] = React.useState(null);\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const firstRowIndex = getIndexFromScroll(top, rowsMeta.positions);\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getIndexFromScroll(top + rootRef.current.clientHeight, rowsMeta.positions);\n    const firstColumnIndex = getIndexFromScroll(left, columnPositions);\n    const lastColumnIndex = getIndexFromScroll(left + containerWidth, columnPositions);\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, rowsMeta.positions, rootProps.autoHeight, currentPage.rows.length, columnPositions, containerWidth, visibleColumns.length]);\n  React.useEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  React.useEffect(() => {\n    setContainerWidth(rootRef.current.clientWidth);\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(() => {\n    if (rootRef.current) {\n      setContainerWidth(rootRef.current.clientWidth);\n    }\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  React.useLayoutEffect(() => {\n    if (renderContext) {\n      updateRenderZonePosition(renderContext);\n    }\n  }, [renderContext, updateRenderZonePosition]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    setRenderContext(nextRenderContext);\n    prevRenderContext.current = nextRenderContext;\n  }, [setRenderContext, prevRenderContext]);\n  React.useEffect(() => {\n    if (containerWidth == null) {\n      return;\n    }\n\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);\n\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n\n  const getRows = function () {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      renderContext\n    };\n    const {\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerWidth\n    } = params;\n\n    if (!currentPage.range || !nextRenderContext || availableSpace == null) {\n      return null;\n    }\n\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n      const row = currentPage.rows[i];\n      renderedRows.push(row);\n      apiRef.current.unstable_calculateColSpan({\n        rowId: row.id,\n        minFirstColumn,\n        maxLastColumn\n      });\n    }\n\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    const rows = [];\n\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _rootProps$components;\n\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const targetRowHeight = apiRef.current.unstable_getRowHeight(id);\n      let isSelected;\n\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else if (typeof rootProps.isRowSelectable === 'function') {\n        isSelected = rootProps.isRowSelectable(apiRef.current.getRowParams(id));\n      } else {\n        isSelected = true;\n      }\n\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: targetRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: currentPage.range.firstRowIndex + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n\n    return rows;\n  };\n\n  const needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: function () {\n      let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      let {\n        style = {}\n      } = _ref,\n          other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: function () {\n      let {\n        style = {}\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        style: _extends({}, style, contentSize)\n      };\n    },\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};","map":{"version":3,"sources":["C:/Users/Jueun/Desktop/89/Frontend/Frontend_react/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"names":["_objectWithoutPropertiesLoose","_extends","_excluded","React","ReactDOM","useForkRef","useGridApiContext","useGridRootProps","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnsTotalWidthSelector","gridColumnPositionsSelector","gridDensityRowHeightSelector","gridFocusCellSelector","gridTabIndexCellSelector","gridEditRowsStateSelector","useGridVisibleRows","useGridApiEventHandler","clamp","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","jsx","_jsx","getIndexFromScroll","offset","positions","sliceStart","sliceEnd","length","pivot","Math","floor","itemOffset","getRenderableIndexes","firstIndex","lastIndex","buffer","minFirstIndex","maxLastIndex","useGridVirtualScroller","props","apiRef","rootProps","visibleColumns","ref","disableVirtualization","onRenderZonePositioning","renderZoneMinColumnIndex","renderZoneMaxColumnIndex","getRowProps","columnPositions","columnsTotalWidth","rowHeight","cellFocus","cellTabIndex","rowsMeta","editRowsState","selectedRowsLookup","currentPage","renderZoneRef","useRef","rootRef","handleRef","renderContext","setRenderContext","useState","prevRenderContext","scrollPosition","top","left","containerWidth","setContainerWidth","prevTotalWidth","computeRenderContext","useCallback","firstRowIndex","lastRowIndex","rows","firstColumnIndex","lastColumnIndex","current","autoHeight","clientHeight","useEffect","style","transform","scrollLeft","scrollTop","clientWidth","currentPageTotalHeight","handleResize","updateRenderZonePosition","nextRenderContext","firstRowToRender","lastRowToRender","rowBuffer","initialFirstColumnToRender","columnBuffer","firstColumnToRender","visibleRows","state","useLayoutEffect","updateRenderContext","initialRenderContext","params","publishEvent","handleScroll","event","currentTarget","topRowsScrolledSincePreviousRender","abs","bottomRowsScrolledSincePreviousRender","topColumnsScrolledSincePreviousRender","bottomColumnsScrolledSincePreviousRender","shouldSetState","rowThreshold","columnThreshold","flushSync","handleWheel","handleTouchMove","getRows","minFirstColumn","maxLastColumn","availableSpace","range","renderedRows","i","row","push","unstable_calculateColSpan","rowId","id","lastColumnToRender","renderedColumns","slice","_rootProps$components","model","lastVisibleRowIndex","targetRowHeight","unstable_getRowHeight","isSelected","isRowSelectable","getRowParams","components","Row","selected","index","isLastVisible","componentsProps","needsHorizontalScrollbar","contentSize","useMemo","height","max","shouldExtendContent","size","width","minHeight","rootStyle","overflowX","getRenderContext","unstable_getRenderContext","getRootProps","_ref","other","onScroll","onWheel","onTouchMove","getContentProps","getRenderZoneProps"],"mappings":"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","sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nconst _excluded = [\"style\"];\r\nimport * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport { useForkRef } from '@mui/material/utils';\r\nimport { useGridApiContext } from '../../utils/useGridApiContext';\r\nimport { useGridRootProps } from '../../utils/useGridRootProps';\r\nimport { useGridSelector } from '../../utils/useGridSelector';\r\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\r\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\r\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\r\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\r\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\r\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\r\nimport { clamp } from '../../../utils/utils';\r\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\r\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\r\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\r\n\r\nimport { jsx as _jsx } from \"react/jsx-runtime\";\r\nexport function getIndexFromScroll(offset, positions, sliceStart = 0, sliceEnd = positions.length) {\r\n  if (positions.length <= 0) {\r\n    return -1;\r\n  }\r\n\r\n  if (sliceStart >= sliceEnd) {\r\n    return sliceStart;\r\n  }\r\n\r\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\r\n  const itemOffset = positions[pivot];\r\n  return offset <= itemOffset ? getIndexFromScroll(offset, positions, sliceStart, pivot) : getIndexFromScroll(offset, positions, pivot + 1, sliceEnd);\r\n}\r\nexport const getRenderableIndexes = ({\r\n  firstIndex,\r\n  lastIndex,\r\n  buffer,\r\n  minFirstIndex,\r\n  maxLastIndex\r\n}) => {\r\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\r\n};\r\nexport const useGridVirtualScroller = props => {\r\n  const apiRef = useGridApiContext();\r\n  const rootProps = useGridRootProps();\r\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\r\n  const {\r\n    ref,\r\n    disableVirtualization,\r\n    onRenderZonePositioning,\r\n    renderZoneMinColumnIndex = 0,\r\n    renderZoneMaxColumnIndex = visibleColumns.length,\r\n    getRowProps\r\n  } = props;\r\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\r\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\r\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\r\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\r\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\r\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\r\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\r\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\r\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\r\n  const renderZoneRef = React.useRef(null);\r\n  const rootRef = React.useRef(null);\r\n  const handleRef = useForkRef(ref, rootRef);\r\n  const [renderContext, setRenderContext] = React.useState(null);\r\n  const prevRenderContext = React.useRef(renderContext);\r\n  const scrollPosition = React.useRef({\r\n    top: 0,\r\n    left: 0\r\n  });\r\n  const [containerWidth, setContainerWidth] = React.useState(null);\r\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\r\n  const computeRenderContext = React.useCallback(() => {\r\n    if (disableVirtualization) {\r\n      return {\r\n        firstRowIndex: 0,\r\n        lastRowIndex: currentPage.rows.length,\r\n        firstColumnIndex: 0,\r\n        lastColumnIndex: visibleColumns.length\r\n      };\r\n    }\r\n\r\n    const {\r\n      top,\r\n      left\r\n    } = scrollPosition.current;\r\n    const firstRowIndex = getIndexFromScroll(top, rowsMeta.positions);\r\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getIndexFromScroll(top + rootRef.current.clientHeight, rowsMeta.positions);\r\n    const firstColumnIndex = getIndexFromScroll(left, columnPositions);\r\n    const lastColumnIndex = getIndexFromScroll(left + containerWidth, columnPositions);\r\n    return {\r\n      firstRowIndex,\r\n      lastRowIndex,\r\n      firstColumnIndex,\r\n      lastColumnIndex\r\n    };\r\n  }, [disableVirtualization, rowsMeta.positions, rootProps.autoHeight, currentPage.rows.length, columnPositions, containerWidth, visibleColumns.length]);\r\n  React.useEffect(() => {\r\n    if (disableVirtualization) {\r\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\r\n    } else {\r\n      // TODO a scroll reset should not be necessary\r\n      rootRef.current.scrollLeft = 0;\r\n      rootRef.current.scrollTop = 0;\r\n    }\r\n  }, [disableVirtualization]);\r\n  React.useEffect(() => {\r\n    setContainerWidth(rootRef.current.clientWidth);\r\n  }, [rowsMeta.currentPageTotalHeight]);\r\n  const handleResize = React.useCallback(() => {\r\n    if (rootRef.current) {\r\n      setContainerWidth(rootRef.current.clientWidth);\r\n    }\r\n  }, []);\r\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\r\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\r\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\r\n      firstIndex: nextRenderContext.firstRowIndex,\r\n      lastIndex: nextRenderContext.lastRowIndex,\r\n      minFirstIndex: 0,\r\n      maxLastIndex: currentPage.rows.length,\r\n      buffer: rootProps.rowBuffer\r\n    });\r\n    const [initialFirstColumnToRender] = getRenderableIndexes({\r\n      firstIndex: nextRenderContext.firstColumnIndex,\r\n      lastIndex: nextRenderContext.lastColumnIndex,\r\n      minFirstIndex: renderZoneMinColumnIndex,\r\n      maxLastIndex: renderZoneMaxColumnIndex,\r\n      buffer: rootProps.columnBuffer\r\n    });\r\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\r\n      firstColumnToRender: initialFirstColumnToRender,\r\n      apiRef,\r\n      firstRowToRender,\r\n      lastRowToRender,\r\n      visibleRows: currentPage.rows\r\n    });\r\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\r\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\r\n\r\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\r\n\r\n    if (typeof onRenderZonePositioning === 'function') {\r\n      onRenderZonePositioning({\r\n        top,\r\n        left\r\n      });\r\n    }\r\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\r\n  React.useLayoutEffect(() => {\r\n    if (renderContext) {\r\n      updateRenderZonePosition(renderContext);\r\n    }\r\n  }, [renderContext, updateRenderZonePosition]);\r\n  const updateRenderContext = React.useCallback(nextRenderContext => {\r\n    setRenderContext(nextRenderContext);\r\n    prevRenderContext.current = nextRenderContext;\r\n  }, [setRenderContext, prevRenderContext]);\r\n  React.useEffect(() => {\r\n    if (containerWidth == null) {\r\n      return;\r\n    }\r\n\r\n    const initialRenderContext = computeRenderContext();\r\n    updateRenderContext(initialRenderContext);\r\n    const {\r\n      top,\r\n      left\r\n    } = scrollPosition.current;\r\n    const params = {\r\n      top,\r\n      left,\r\n      renderContext: initialRenderContext\r\n    };\r\n    apiRef.current.publishEvent('rowsScroll', params);\r\n  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);\r\n\r\n  const handleScroll = event => {\r\n    const {\r\n      scrollTop,\r\n      scrollLeft\r\n    } = event.currentTarget;\r\n    scrollPosition.current.top = scrollTop;\r\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\r\n\r\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\r\n      return;\r\n    } // When virtualization is disabled, the context never changes during scroll\r\n\r\n\r\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\r\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\r\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\r\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\r\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\r\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\r\n\r\n    apiRef.current.publishEvent('rowsScroll', {\r\n      top: scrollTop,\r\n      left: scrollLeft,\r\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\r\n    }, event);\r\n\r\n    if (shouldSetState) {\r\n      // Prevents batching render context changes\r\n      ReactDOM.flushSync(() => {\r\n        updateRenderContext(nextRenderContext);\r\n      });\r\n      prevTotalWidth.current = columnsTotalWidth;\r\n    }\r\n  };\r\n\r\n  const handleWheel = event => {\r\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\r\n  };\r\n\r\n  const handleTouchMove = event => {\r\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\r\n  };\r\n\r\n  const getRows = (params = {\r\n    renderContext\r\n  }) => {\r\n    const {\r\n      renderContext: nextRenderContext,\r\n      minFirstColumn = renderZoneMinColumnIndex,\r\n      maxLastColumn = renderZoneMaxColumnIndex,\r\n      availableSpace = containerWidth\r\n    } = params;\r\n\r\n    if (!currentPage.range || !nextRenderContext || availableSpace == null) {\r\n      return null;\r\n    }\r\n\r\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\r\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\r\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\r\n      firstIndex: nextRenderContext.firstRowIndex,\r\n      lastIndex: nextRenderContext.lastRowIndex,\r\n      minFirstIndex: 0,\r\n      maxLastIndex: currentPage.rows.length,\r\n      buffer: rowBuffer\r\n    });\r\n    const renderedRows = [];\r\n\r\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\r\n      const row = currentPage.rows[i];\r\n      renderedRows.push(row);\r\n      apiRef.current.unstable_calculateColSpan({\r\n        rowId: row.id,\r\n        minFirstColumn,\r\n        maxLastColumn\r\n      });\r\n    }\r\n\r\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\r\n      firstIndex: nextRenderContext.firstColumnIndex,\r\n      lastIndex: nextRenderContext.lastColumnIndex,\r\n      minFirstIndex: minFirstColumn,\r\n      maxLastIndex: maxLastColumn,\r\n      buffer: columnBuffer\r\n    });\r\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\r\n      firstColumnToRender: initialFirstColumnToRender,\r\n      apiRef,\r\n      firstRowToRender,\r\n      lastRowToRender,\r\n      visibleRows: currentPage.rows\r\n    });\r\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\r\n    const rows = [];\r\n\r\n    for (let i = 0; i < renderedRows.length; i += 1) {\r\n      var _rootProps$components;\r\n\r\n      const {\r\n        id,\r\n        model\r\n      } = renderedRows[i];\r\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\r\n      const targetRowHeight = apiRef.current.unstable_getRowHeight(id);\r\n      let isSelected;\r\n\r\n      if (selectedRowsLookup[id] == null) {\r\n        isSelected = false;\r\n      } else if (typeof rootProps.isRowSelectable === 'function') {\r\n        isSelected = rootProps.isRowSelectable(apiRef.current.getRowParams(id));\r\n      } else {\r\n        isSelected = true;\r\n      }\r\n\r\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\r\n        row: model,\r\n        rowId: id,\r\n        rowHeight: targetRowHeight,\r\n        cellFocus: cellFocus // TODO move to inside the row\r\n        ,\r\n        cellTabIndex: cellTabIndex // TODO move to inside the row\r\n        ,\r\n        editRowsState: editRowsState // TODO move to inside the row\r\n        ,\r\n        renderedColumns: renderedColumns,\r\n        visibleColumns: visibleColumns,\r\n        firstColumnToRender: firstColumnToRender,\r\n        lastColumnToRender: lastColumnToRender,\r\n        selected: isSelected,\r\n        index: currentPage.range.firstRowIndex + firstRowToRender + i,\r\n        containerWidth: availableSpace,\r\n        isLastVisible: lastVisibleRowIndex\r\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\r\n    }\r\n\r\n    return rows;\r\n  };\r\n\r\n  const needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;\r\n  const contentSize = React.useMemo(() => {\r\n    // In cases where the columns exceed the available width,\r\n    // the horizontal scrollbar should be shown even when there're no rows.\r\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\r\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\r\n    let shouldExtendContent = false;\r\n\r\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\r\n      shouldExtendContent = true;\r\n    }\r\n\r\n    const size = {\r\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\r\n      height,\r\n      minHeight: shouldExtendContent ? '100%' : 'auto'\r\n    };\r\n\r\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\r\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\r\n    }\r\n\r\n    return size;\r\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\r\n  React.useEffect(() => {\r\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\r\n  }, [apiRef, contentSize]);\r\n\r\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\r\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\r\n  }\r\n\r\n  const rootStyle = {};\r\n\r\n  if (!needsHorizontalScrollbar) {\r\n    rootStyle.overflowX = 'hidden';\r\n  }\r\n\r\n  const getRenderContext = React.useCallback(() => {\r\n    return prevRenderContext.current;\r\n  }, []);\r\n  apiRef.current.unstable_getRenderContext = getRenderContext;\r\n  return {\r\n    renderContext,\r\n    updateRenderZonePosition,\r\n    getRows,\r\n    getRootProps: (_ref = {}) => {\r\n      let {\r\n        style = {}\r\n      } = _ref,\r\n          other = _objectWithoutPropertiesLoose(_ref, _excluded);\r\n\r\n      return _extends({\r\n        ref: handleRef,\r\n        onScroll: handleScroll,\r\n        onWheel: handleWheel,\r\n        onTouchMove: handleTouchMove,\r\n        style: _extends({}, style, rootStyle)\r\n      }, other);\r\n    },\r\n    getContentProps: ({\r\n      style = {}\r\n    } = {}) => ({\r\n      style: _extends({}, style, contentSize)\r\n    }),\r\n    getRenderZoneProps: () => ({\r\n      ref: renderZoneRef\r\n    })\r\n  };\r\n};"]},"metadata":{},"sourceType":"module"}